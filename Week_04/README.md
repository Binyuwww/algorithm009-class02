# Week04 学习笔记
## 1. 深度优先搜索和广度优先搜索 (DFS & BFS)

遍历搜索：在树（图/状态集）中寻找特定节点。每个节点都要访问一次且仅访问一次。

根据节点的访问顺序不同，分成深度优先搜索、广度优先搜索和启发式搜索（根据优先级决定访问顺序）。

### Depth First Search

深度优先搜索使用递归或栈实现。

对于树的深度优先搜索，首先访问根节点，然后递归遍历每个子树，一个子树遍历完毕再遍历另一个子树。

对于图的深度优先搜索，从起点开始，和树的情况相似。

### Breadth First Search

广度优先搜索使用队列实现。

广度优先搜索每次遍历位于同一层的所有节点，可以用于最短路径求解。

## 2. 贪心算法 (Greedy)

### 贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心算法可以解决一些最优化问题，但是并不总是能得到最优解。

### 适用场景

问题能够分解成子问题解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

贪心算法不能回退，因此每个子问题都必须具有最优子结构。

## 3. 二分查找(Binary Search)

### 前提

    - 目标函数单调性（单调递增或递减）。

    - 存在上下界（bounded）。

    - 能够通过索引访问（index accessible）。

### 模板

例如在有序数组中查找目标值。

    - 定义下界和上界，分别为数组的左右两端下标。

    - 每次取下界和上界的中间位置下标，获得中间位置下标处的元素，并与目标值比较。

    - 如果中间位置下标处的元素与目标值相等，说明已经找到该元素，返回中间位置下标即可。

    - 如果中间位置下标处的元素小于目标值，则将下界移动到中间位置下标的右边一位。如果中间位置下标处的元素大于目标值，则将上界移动到中间位置下标的左边一位。

    - 更新下界和上界后，重复第2步到第4步，直到找到目标值，或者直到下界大于上界，则说明目标值不存在。

## 4. 使用二分查找，寻找半有序数组中间无序的地方

参考153题， 用二分法找到“旋转轴”， 其对应下标即为乱序开始的地方。

    - 为什么？ 
    - 升序数组内所有元素按由小到大排列，无序处即为旋转开始处，也就是最小值所在处。

```java
class Solution {
    public int findNoOrder(int[] nums) {
        //Corner case
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int l = 0;
        int r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
    
            if (nums[mid] < nums[r]) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}
```



### - 深度优先搜索和广度优先搜索

深度优先搜索和广度优先搜索是图中常用的搜索算法，在树和二叉树中，这两种搜索算法被广泛使用。

深度优先搜索使用栈数据结构，常用递归实现，也可以手动维护栈使用迭代实现。

广度优先搜索使用队列数据结构，常用迭代实现。

深度优先搜索可访问到所有可到达的节点，但不保证最短距离，广度优先搜索不仅可访问到所有可到达的节点，还能保证最短距离。

### - 贪心算法

贪心算法的核心是“贪心”，即每一步选择都只考虑当前状态下最有利的选择。由于贪心算法不能回退，因此虽然贪心算法可以解决一些最优化问题，但是并不总是能得到最优解。

### - 二分查找

二分查找的适用条件包括：目标函数单调性、存在上下界、能够通过索引访问。

二分查找的套路是，根据上下界找到中间位置，判断中间位置的值和目标值的关系，如果相等则直接返回，否则判断中间位置的哪一侧的查找范围应该保留，将查找范围缩小一半后继续查找，直到找到目标值或者下界大于上界。

实际使用二分查找时，需要对于具体问题考虑上界和下界的定义、二分查找的条件和更新上界和下界的规则。
